---
layout: post
title: Lease机制
date: 2022-6-10 20:00:01 +0800
categories: 分布式
tags: lease 
author: Rxsi
---

* content
{:toc}

## 简介
Lease机制又叫租约机制，具有以下几个特点：

1. 颁布者对请求者下发 lease 绝对时间戳，保证在这段时间内数据的一致性（**注意：这依赖于机器时钟**)
2. 颁布者下发 lease 之后，不管是否被对端成功接收到，只要 lease 不过期，则该段时间内都不能对元数据进行修改，否则会破坏数据一致性
3. lease 的持有者只能在有效期内具有执行权限，当超时后，要么放弃执行，要么重新申请 lease
<!--more-->

## 解决的问题
### 基于 lease 机制的分布式缓存系统
传统的缓存系统为了保证缓存数据与中心节点（该中心节点往往是数据库）的数据一致性，往往采用单缓存节点的形式，即所有节点访问数据时先访问该缓存节点，当缓存节点有数据时直接返回，否则再访问中心数据节点。这种方案在数据访问量大时，缓存节点会成为性能瓶颈，因此有一定的局限性。同时缓存节点与中心节点数据的更新逻辑也有许多考究，具体参考：**_缓存策略_**一文。

为了解决上述的缓存节点存在的性能瓶颈，可以采取的解决方案有：

1. 方案1是使用多个缓存节点，每个缓存节点以一定的规则存储一定范围的数据（哈希、按数据范围、一致性哈希），这样就可以把访问压力均分到多个缓存节点上，提升系统的并发承载能力。每个子缓存节点都是一个独立的缓存系统，因此可以直接沿用单节点时的缓存数据更新方案。但这个方案也有一定的局限性，如某个缓存节点宕机，那么原先该节点的访问需要都打到中心节点，会使中心节点的IO访问迅速增加。同时该方案的可拓展性不佳，动态扩展需要进行“洗数据”处理，且容易出现“数据倾斜”的问题。
2. 方案2同样采用多缓存节点的形式，每个缓存节点可以是客户端本身，但是每个缓存节点都拥有完整的缓存数据，这就需要使用 lease 机制来保证多节点之间的数据一致性

#### 实现流程

1. 每个客户端都视为自身节点的缓存节点
2. 客户端访问数据时首先判断本地是否有缓存，且 lease 是否处于有效期内
3. 当处于有效期中，则可以直接使用该份缓存数据，否则需要向中心节点请求新数据
4. 中心节点接收到读请求后，返回新数据及一个新的 lease 时间戳，且不用管该消息是否被对方节点成功接收
5. 客户端接收到新数据及新 lease 时间戳后，更新本地缓存，如果未能接收到中心节点返回的数据，则直接删除本地缓存，视本地读取失败，进而重试
6. 当中心节点接收到某个数据修改的请求时，需要**阻塞**所有关于该待更新数据的读请求，直到与该数据相关的 lease 超时，再修改数据并返回结果给对应的客户端

#### 弊端与改进
通过 lease 机制，可以保证多个节点之间的数据一致性，但是 lease 机制本身存在一定的局限性，就是依赖于各个节点的机器时钟。因此当采用 lease 机制实现分布式缓存方案时，要保证各机器时钟的误差不可过大。

另外当中心节点更新数据时需要阻塞等待新的读请求，这是为了保证在更新数据时，所有的缓存副本都已失效，因此在读取该数据时需要到中心节点拉取最新的数据。但是这种阻塞方案无疑会使读性能下降，为了解决这个问题，可以使在进入数据修改流程时，对于期间发生的读请求，可以返回数据和当前下发的最大时间戳的 lease，这样就依然可以保证数据实际发生修改时，所有的缓存副本都已失效。这保证了读请求的实时性。

对于写请求，因为要等待所有与该数据相关的 lease 过期，因此写请求也会有一定的阻塞时间。为了提升写请求的实时性，可以当中心节点接收到写请求时，立即向所有持有该数据 lease 的缓存节点发出缓存过期消息，如果所有的缓存节点都回复成功，则可立即对数据进行修改，而无需等待 lease 超时。

### 基于 lease 机制的选主功能
#### 示例：zookeeper的lease机制
这个顺带在学习zookeeper时补充TODO
#### Lease 与不可服务时长
根据文章 [_Lease与最长宕机时间分析_](http://oceanbase.org.cn/?cat=6)，以 lease 机制实现选主功能来看：

- 假设 lease 时间为 L，则当主节点宕机之后的集群不可服务时间最长为 L，因为至少要等待 L 时间之后才可重新选择主节点，故 L 不可设置过大；
- 假设主节点定时请求新 lease 的时间间隔为 T（T < L），当中心节点宕机重启的耗时要小于 L - T，则不会影响主节点的运行，故 L 不可设置过小；
- 综上，最差的不可运行时间是中心节点刚授权给某主节点 lease，而该主节点就宕机了，然后等到 lease 即将结束之后，中心节点发生了重启，因此总的时间是 **L + D（D < L - T)**
- 根据上面的分析，如果我们是多级的 lease 系统，则**下一级 lease 需要是上一级 lease 的 2.5 倍**，才可以保证上面分析的中心节点/主节点宕机重启的可运行性。如中心节点是集群设计，且依赖于 zookeeper 的选主功能，租约的时间间隔 lease = 10s，则主节点依赖于中心节点的选主功能的 lease 时间要为 25s，此情况下的主节点的不可服务时间最长为 35s

因此在设计时，要避免多级 lease 的结构

